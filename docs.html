<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="./docs.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <title>OS Virtual Lab</title>
</head>

<body>
    <section class="sub-header">
        <nav>
            <a href="index.html">OS Algortithms Simulator</a>
            <div class="nav-links" id="navLinks">
                <i class="fas fa-window-close" onclick="hideMenu()"></i>
                <ul>
                    <li><a href="index.html">HOME</a></li>
                    <li><a href="docs.html">DOCS</a></li>
                    <!-- <li><a href="blog.html">BLOG</a></li> -->
                    <li><a href="./backend/index.html">SIMULATOR</a></li>
                    <li><a href="about.html">ABOUT</a></li>

                </ul>
            </div>
            <i class="fas fa-bars" onclick="showMenu()"></i>
        </nav>

        <h1>Documentation</h1>

    </section>



    <section class="container_docs">
        <h1>What is CPU Scheduling?</h1>
        <p>CPU Scheduling is a process of determining which process will own CPU for execution while another process is
            on hold. The main task of CPU scheduling is to make sure that whenever the CPU remains idle, the OS at least
            select one of the processes available in the ready queue for execution. The selection process will be
            carried out by the CPU scheduler. It selects one of the processes in memory that are ready for execution.
        </p>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Why CPU Scheduling ?</h1>
        <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent
            waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can
            use CPU while another is waiting for I/O. This is possible only with process scheduling.</p>
        <div class="heading">Objectives of Process Scheduling Algorithm :</div>
        <li><strong>Max CPU utilization:</strong> Keep CPU as busy as possible.</li>
        <li><strong>Fair allocation of CPU to each process.</strong></li>
        <li><strong>Max throughput:</strong>Number of processes that complete their execution per time unit]</li>
        <li><strong>Min turnaround time :</strong> Time taken by a process to finish execution.</li>
        <li><strong>Min waiting time:</strong> Time a process waits in ready queue.</li>
        <li><strong>Min response time :</strong>Time when a process produces first response.</li>
        </p>
    </section>

    <section class="container_docs special" data-aos="zoom-in-up">
        <h1>Important CPU scheduling Terminologies</h1>
        <!-- <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br> -->
        <li><strong>Burst Time/Execution Time:</strong> It is a time required by the process to complete execution. It
            is also called running time.</li>
        <li><strong>Arrival Time:</strong> when a process enters in a ready state</li>
        <li><strong>Finish Time:</strong> when process complete and exit from a system</li>
        <li><strong>Multiprogramming:</strong> A number of programs which can be present in memory at the same time.
        </li>
        <li><strong>Jobs:</strong> It is a type of program without any kind of user interaction.</li>
        <li><strong>User:</strong> It is a kind of program having user interaction.</li>
        <li><strong>Process:</strong> It is the reference that is used for both job and user.</li>
        <li><strong>CPU/IO burst cycle:</strong> Characterizes process execution, which alternates between CPU and I/O
            activity. CPU times are shorter than the time of I/O.</li>

        </p>
    </section>



    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU Scheduling</h1>
        <p>There is mainly two major types of CPU Scheduling which is listed below.There is sub-types of this algorithm
            also. we have discussed all algorithm in details below. </p>
        <li>Preemptive Algorithm</li>
        <li>Non Preemptive Algorithm</li>
        <br>
        <p>
            <strong>Preemptive Scheduling</strong><br>
            In Preemptive Scheduling, the tasks are mostly assigned with their priorities. Sometimes it is important to
            run a task with a higher priority before another lower priority task, even if the lower priority task is
            still running. The lower priority task holds for some time and resumes when the higher priority task
            finishes its execution.
            <br>
            <br>
            <strong>Non-Preemptive Scheduling</strong><br>
            In this type of scheduling method, the CPU has been allocated to a specific process. The process that keeps
            the CPU busy will release the CPU either by switching context or terminating. It is the only method that can
            be used for various hardware platforms. That’s because it doesn’t need special hardware (for example, a
            timer) like preemptive scheduling.
        </p>
    </section>


    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU scheduling Algorithm</h1>
        <p>There are mainly six types of process scheduling algorithm :</p>
        <!-- <lo> -->
        <li>First Come First Serve (FCFS)</li>
        <li>Shortest-Job-First (SJF) </li>
        <li>Longest Job First (LJF)</li>
        <li>Shortest Remaining Time First (SRTF)</li>
        <li>Longest Remaining Time First (LRTF)</li>
        <li>Round Robin (RR)</li>
        <li>Priority (Preemptive)</li>
        <li>Priority (Non-Preemptive)</li>
        <li>Highest Response Ratio Next (HRRN)</li>
        <br>
    </section>



    <section class="container_docs" data-aos="zoom-in-up">
        <h1>First Come First Serve</h1>
        <p>First Come First Serve is the full form of FCFS. It is the easiest and most simple CPU scheduling algorithm.
            In this type of algorithm, the process which requests the CPU gets the CPU allocation first. This scheduling
            method can be managed with a FIFO queue.<br>
            <a href="https://www.javatpoint.com/os-fcfs-scheduling">More Info..</a>
        </p>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Shortest Job First</h1>
        <p>SJF is a full form of (Shortest job first) is a scheduling algorithm in which the process with the shortest
            execution time should be selected for execution next. This scheduling method can be preemptive or
            non-preemptive. It significantly reduces the average waiting time for other processes awaiting
            execution.<br>
            <a href="https://www.javatpoint.com/os-sjf-scheduling">More Info...</a>
        </p>
    </section>
    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Longest Job First</h1>
        <p>LJF is a non-preemptive scheduling algorithm. This algorithm is based on the burst time
            of the processes. The processes are put into the ready queue based on their burst times i.e., in descending
            order of the burst times. As the name suggests this algorithm is based on the fact that the process with the
            largest burst time is processed first. The burst time of only those processes is considered that have
            arrived in the system until that time. Its preemptive version is called Longest Remaining Time First (LRTF)
            algorithm. <br>
            <a href="https://www.geeksforgeeks.org/longest-job-first-ljf-cpu-scheduling-algorithm/">More Info...</a>
        </p>
    </section>
    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Shortest Remaining Time First</h1>
        <p>The full form of SRT is Shortest remaining time. It is also known as SJF preemptive scheduling. In this
            method, the process will be allocated to the task, which is closest to its completion. This method prevents
            a newer ready state process from holding the completion of an older process.<br>

            <a href="https://www.javatpoint.com/os-srtf-scheduling-algorithm">More Info..</a>
        </p>
        <br>
    </section>


    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Longest Remaining Time First</h1>
        <p>LRTF is a preemptive version of Longest Job First (LJF) scheduling algorithm.
            In this scheduling algorithm, we find the process with the maximum remaining time and then process it, i.e.
            check for the maximum remaining time after some interval of time(say 1 unit each) to check if another
            process having more Burst Time arrived up to that time. <br>

            <a href="https://www.geeksforgeeks.org/longest-remaining-time-first-lrtf-cpu-scheduling-algorithm/">More
                Info..</a>
        </p>
        <br>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Round-Robin Scheduling</h1>
        <p>Round robin is the oldest, simplest scheduling algorithm. The name of this algorithm comes from the
            round-robin principle, where each person gets an equal share of something in turn. It is mostly used for
            scheduling algorithms in multitasking. This algorithm method helps for starvation free execution of
            processes.<br><br>
            <a href="https://www.javatpoint.com/os-round-robin-scheduling-algorithm">More Info...</a>
        </p>
    </section>
    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Priority (Preemptive)</h1>
        <p>Preemptive Priority CPU Scheduling Algorithm is a pre-emptive method of CPU scheduling algorithm that works
            based on the priority of a process. In this algorithm, the scheduler schedules the tasks to work as per the
            priority, which means that a higher priority process should be executed first. In case of any conflict,
            i.e., when there is more than one process with equal priorities, then the pre-emptive priority CPU
            scheduling algorithm works on the basis of FCFS (First Come First Serve) algorithm.<br><br>
            <a href="https://www.geeksforgeeks.org/preemptive-priority-cpu-scheduling-algortithm/">More Info..</a>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Priority (Non-Preemptive)</h1>
        <p>In non-preemptive priority scheduling, the CPU gets allocated to a specific process based on the priority
            numbers assigned. After the CPU allocation, it will only be released by context switching or terminating the
            process. This scheduling is widely used for various hardware platforms because it doesn't require any
            special hardware (timer etc.) like preemptive scheduling.
            "Process with less priority number will get CPU allocation first."
            <br><br>
            <a href="https://www.educative.io/answers/what-is-a-non-preemptive-priority-scheduling-algorithm">More
                Info..</a>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Highest response Ratio Next</h1>
        <p>Highest Response Ratio Next (HRNN) is one of the most optimal scheduling algorithms. This is a non-preemptive
            algorithm in which, the scheduling is done on the basis of an extra parameter called Response Ratio. A
            Response Ratio is calculated for each of the available jobs and the Job with the highest response ratio is
            given priority over the others.
            <br><br>
            <a href="https://www.javatpoint.com/os-hrrn-scheduling">More
                Info..</a>
    </section>

    <section class="footer">
        <!-- <h4>About Us</h4>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Soluta pariatur eveniet eaque provident error velit totam quos. Corrupti sunt omnis<br>  eligendi ut enim, sed magnamquo laboriosam, aspernatur nulla ipsum commodi itaque accusantium sapiente!</p> -->

        <div class="icons">
            <a href="https://www.facebook.com"><i class="fab fa-facebook"></i></a>
            <a href="https://www.instagram.com/invites/contact/?i=17s1o7wfms500&utm_content=i08g8yn"><i
                    class="fab fa-instagram"></i></a>
            <a href="https://twitter.com/Krutarth12345?t=JASTMDZLzUB4VOR-OEd_kg&s=09"><i class="fab fa-twitter"></i></a>
            <a href="https://www.linkedin.com/in/krutarth-patel-653065205 "><i class="fab fa-linkedin"></i></a>
        </div>

        <p>Made With <i class="far fa-heart"></i> by Team SnowFall</p>
        <p> <i class="fa fa-copyright"></i> copyright 2023 || All rights reserved</p>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
        integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
        crossorigin="anonymous"></script>

    <script>
        var navLinks = document.getElementById("navLinks");
        function showMenu() {
            navLinks.style.right = "0";
        }

        function hideMenu() {
            navLinks.style.right = "-200px";
        }

        function gotoSimulator() {
            location.href = ("./backend/ganttcharts.html");
        }
    </script>


    <!-- For the animation -->
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>
        AOS.init({
            offset: 200, // offset (in px) from the original trigger point
            duration: 800
        });
    </script>
</body>

</html>